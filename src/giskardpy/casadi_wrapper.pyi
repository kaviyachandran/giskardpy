import builtins
import casadi as ca
from giskardpy.my_types import Derivatives as Derivatives, PrefixName as PrefixName
from giskardpy.utils import logging as logging
from typing import Any, Optional, Union

builtin_max: Any
builtin_min: Any
builtin_abs = builtins.abs
pi: Any

class StackedCompiledFunction:
    compiled_f: Any = ...
    split_out_view: Any = ...
    def __init__(self, expressions: Any, parameters: Optional[Any] = ..., additional_views: Optional[Any] = ...) -> None: ...
    def fast_call(self, filtered_args: Any): ...

class CompiledFunction:
    sparse: Any = ...
    str_params: Any = ...
    compiled_f: Any = ...
    out: Any = ...
    def __init__(self, expression: Any, parameters: Optional[Any] = ..., sparse: bool = ...) -> None: ...
    def __call__(self, **kwargs: Any): ...
    def fast_call(self, filtered_args: Any): ...

class Symbol_:
    s: ca.SX
    def pretty_str(self): ...
    def __hash__(self) -> Any: ...
    def __getitem__(self, item: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    @property
    def shape(self): ...
    def __len__(self): ...
    def free_symbols(self): ...
    def evaluate(self): ...
    def compile(self, parameters: Optional[Any] = ..., sparse: bool = ...): ...

class Symbol(Symbol_):
    s: Any = ...
    def __init__(self, name: str) -> Any: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    def __rtruediv__(self, other: Any): ...
    def __floordiv__(self, other: Any): ...
    def __mod__(self, other: Any): ...
    def __divmod__(self, other: Any): ...
    def __rfloordiv__(self, other: Any): ...
    def __rmod__(self, other: Any): ...
    def __rdivmod__(self, other: Any): ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __neg__(self): ...
    def __pow__(self, other: Any): ...
    def __rpow__(self, other: Any): ...
    def __hash__(self) -> Any: ...

class Expression(Symbol_):
    s: Any = ...
    def __init__(self, data: Optional[Any] = ...) -> None: ...
    def remove(self, rows: Any, columns: Any) -> None: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    def __rtruediv__(self, other: Any): ...
    def __floordiv__(self, other: Any): ...
    def __mod__(self, other: Any): ...
    def __divmod__(self, other: Any): ...
    def __rfloordiv__(self, other: Any): ...
    def __rmod__(self, other: Any): ...
    def __rdivmod__(self, other: Any): ...
    def __abs__(self): ...
    def __floor__(self): ...
    def __ceil__(self): ...
    def __ge__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __neg__(self): ...
    def __pow__(self, other: Any): ...
    def __rpow__(self, other: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def dot(self, other: Any): ...
    @property
    def T(self): ...
    def reshape(self, new_shape: Any): ...

class TransMatrix(Symbol_):
    reference_frame: Any = ...
    child_frame: Any = ...
    s: Any = ...
    def __init__(self, data: Optional[Any] = ..., sanity_check: bool = ...) -> None: ...
    @classmethod
    def from_point_rotation_matrix(cls, point: Optional[Any] = ..., rotation_matrix: Optional[Any] = ...): ...
    def dot(self, other: Any): ...
    def inverse(self): ...
    @classmethod
    def from_xyz_rpy(cls, x: Optional[Any] = ..., y: Optional[Any] = ..., z: Optional[Any] = ..., roll: Optional[Any] = ..., pitch: Optional[Any] = ..., yaw: Optional[Any] = ...): ...
    def to_position(self): ...
    def to_translation(self): ...
    def to_rotation(self): ...

class RotationMatrix(Symbol_):
    reference_frame: Any = ...
    s: Any = ...
    def __init__(self, data: Optional[Any] = ..., sanity_check: bool = ...) -> None: ...
    @classmethod
    def from_axis_angle(cls, axis: Any, angle: Any): ...
    @classmethod
    def from_quaternion(cls, q: Any): ...
    def dot(self, other: Any): ...
    def to_axis_angle(self): ...
    def to_angle(self, hint: Any): ...
    @classmethod
    def from_vectors(cls, x: Optional[Any] = ..., y: Optional[Any] = ..., z: Optional[Any] = ...): ...
    @classmethod
    def from_rpy(cls, roll: Optional[Any] = ..., pitch: Optional[Any] = ..., yaw: Optional[Any] = ...): ...
    def inverse(self): ...
    def to_rpy(self): ...
    def to_quaternion(self): ...
    def normalize(self) -> None: ...
    @property
    def T(self): ...

class Point3(Symbol_):
    reference_frame: Any = ...
    s: Any = ...
    def __init__(self, data: Optional[Any] = ...) -> None: ...
    @classmethod
    def from_xyz(cls, x: Optional[Any] = ..., y: Optional[Any] = ..., z: Optional[Any] = ...): ...
    def norm(self): ...
    @property
    def x(self): ...
    @x.setter
    def x(self, value: Any) -> None: ...
    @property
    def y(self): ...
    @y.setter
    def y(self, value: Any) -> None: ...
    @property
    def z(self): ...
    @z.setter
    def z(self, value: Any) -> None: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    def __rtruediv__(self, other: Any): ...
    def __neg__(self) -> Point3: ...
    def __pow__(self, other: Any): ...
    def __rpow__(self, other: Any): ...
    def dot(self, other: Any): ...

class Vector3(Symbol_):
    s: Any = ...
    reference_frame: Any = ...
    vis_frame: Any = ...
    def __init__(self, data: Optional[Any] = ...) -> None: ...
    @classmethod
    def from_xyz(cls, x: Optional[Any] = ..., y: Optional[Any] = ..., z: Optional[Any] = ...): ...
    @property
    def x(self): ...
    @x.setter
    def x(self, value: Any) -> None: ...
    @property
    def y(self): ...
    @y.setter
    def y(self, value: Any) -> None: ...
    @property
    def z(self): ...
    @z.setter
    def z(self, value: Any) -> None: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __pow__(self, other: Any): ...
    def __rpow__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    def __rtruediv__(self, other: Any): ...
    def __neg__(self): ...
    def dot(self, other: Any): ...
    def cross(self, other: Any): ...
    def norm(self): ...
    def scale(self, a: Any) -> None: ...

class Quaternion(Symbol_):
    s: Any = ...
    def __init__(self, data: Optional[Any] = ...) -> None: ...
    def __neg__(self): ...
    @classmethod
    def from_xyzw(cls, x: Any, y: Any, z: Any, w: Any): ...
    @property
    def x(self): ...
    @x.setter
    def x(self, value: Any) -> None: ...
    @property
    def y(self): ...
    @y.setter
    def y(self, value: Any) -> None: ...
    @property
    def z(self): ...
    @z.setter
    def z(self, value: Any) -> None: ...
    @property
    def w(self): ...
    @w.setter
    def w(self, value: Any) -> None: ...
    @classmethod
    def from_axis_angle(cls, axis: Any, angle: Any): ...
    @classmethod
    def from_rpy(cls, roll: Any, pitch: Any, yaw: Any): ...
    @classmethod
    def from_rotation_matrix(cls, r: Any): ...
    def conjugate(self): ...
    def multiply(self, q: Any): ...
    def diff(self, q: Any): ...
    def norm(self): ...
    def normalize(self) -> None: ...
    def to_axis_angle(self): ...
    def to_rotation_matrix(self): ...
    def to_rpy(self): ...
    def dot(self, other: Any): ...
all_expressions = Union[Symbol_, Symbol, Expression, Point3, Vector3, RotationMatrix, TransMatrix, Quaternion]
all_expressions_float = Union[Symbol, Expression, Point3, Vector3, RotationMatrix, TransMatrix, float, Quaternion]
symbol_expr_float = Union[Symbol, Expression, float]
symbol_expr = Union[Symbol, Expression]

def var(variables_names: str) -> Any: ...
def diag(args: Any): ...
def jacobian(expressions: Any, symbols: Any): ...
def jacobian_dot(expressions: Any, symbols: Any, symbols_dot: Any): ...
def jacobian_ddot(expressions: Any, symbols: Any, symbols_dot: Any, symbols_ddot: Any): ...
def equivalent(expression1: Any, expression2: Any): ...
def free_symbols(expression: Any): ...
def create_symbols(names: Any): ...
def compile_and_execute(f: Any, params: Any): ...
def zeros(x: Any, y: Any): ...
def ones(x: Any, y: Any): ...
def abs(x: Any): ...
def max(x: Any, y: Optional[Any] = ...): ...
def min(x: Any, y: Optional[Any] = ...): ...
def limit(x: Any, lower_limit: Any, upper_limit: Any): ...
def if_else(condition: Any, if_result: Any, else_result: Any): ...
def equal(x: Any, y: Any): ...
def less_equal(x: Any, y: Any): ...
def greater_equal(x: Any, y: Any): ...
def less(x: Any, y: Any): ...
def greater(x: Any, y: Any, decimal_places: Optional[Any] = ...): ...
def logic_and(*args: Any): ...
def logic_any(args: Any): ...
def logic_all(args: Any): ...
def logic_or(*args: Any): ...
def logic_not(expr: Any): ...
def if_greater(a: Any, b: Any, if_result: Any, else_result: Any): ...
def if_less(a: Any, b: Any, if_result: Any, else_result: Any): ...
def if_greater_zero(condition: Any, if_result: Any, else_result: Any): ...
def if_greater_eq_zero(condition: Any, if_result: Any, else_result: Any): ...
def if_greater_eq(a: Any, b: Any, if_result: Any, else_result: Any): ...
def if_less_eq(a: Any, b: Any, if_result: Any, else_result: Any): ...
def if_eq_zero(condition: Any, if_result: Any, else_result: Any): ...
def if_eq(a: Any, b: Any, if_result: Any, else_result: Any): ...
def if_eq_cases(a: Any, b_result_cases: Any, else_result: Any): ...
def if_less_eq_cases(a: Any, b_result_cases: Any, else_result: Any): ...
def cross(u: Any, v: Any): ...
def norm(v: Any): ...
def scale(v: Any, a: Any): ...
def dot(e1: Any, e2: Any): ...
def eye(size: Any): ...
def kron(m1: Any, m2: Any): ...
def trace(matrix: Any): ...
def vstack(list_of_matrices: Any): ...
def hstack(list_of_matrices: Any): ...
def diag_stack(list_of_matrices: Any): ...
def normalize_axis_angle(axis: Any, angle: Any): ...
def axis_angle_from_rpy(roll: Any, pitch: Any, yaw: Any): ...
def cosine_distance(v0: Any, v1: Any): ...
def euclidean_distance(v1: Any, v2: Any): ...
def fmod(a: Any, b: Any): ...
def euclidean_division(nominator: Any, denominator: Any) -> None: ...
def normalize_angle_positive(angle: Any): ...
def normalize_angle(angle: Any): ...
def shortest_angular_distance(from_angle: Any, to_angle: Any): ...
def quaternion_slerp(q1: Any, q2: Any, t: Any): ...
def slerp(v1: Any, v2: Any, t: Any): ...
def save_division(nominator: Any, denominator: Any, if_nan: Optional[Any] = ...): ...
def save_acos(angle: Any): ...
def entrywise_product(matrix1: Any, matrix2: Any): ...
def floor(x: Any): ...
def ceil(x: Any): ...
def round_up(x: Any, decimal_places: Any): ...
def round_down(x: Any, decimal_places: Any): ...
def sum(matrix: Any): ...
def sum_row(matrix: Expression) -> Expression: ...
def sum_column(matrix: Any): ...
def distance_point_to_line_segment(frame_P_current: Any, frame_P_line_start: Any, frame_P_line_end: Any): ...
def distance_point_to_rectangular_surface(frame_P_current: Any, frame_P_bottom_left: Any, frame_P_bottom_right: Any, frame_P_top_left: Any): ...
def angle_between_vector(v1: Any, v2: Any): ...
def velocity_limit_from_position_limit(acceleration_limit: Any, position_limit: Any, current_position: Any, step_size: Any, eps: float = ...): ...
def to_str(expression: Any): ...
def total_derivative(expr: Any, symbols: Any, symbols_dot: Any): ...
def total_derivative2(expr: Any, symbols: Any, symbols_dot: Any, symbols_ddot: Any): ...
def quaternion_multiply(q1: Any, q2: Any): ...
def quaternion_conjugate(q: Any): ...
def quaternion_diff(q1: Any, q2: Any): ...
def sign(x: Any): ...
def cos(x: Any): ...
def sin(x: Any): ...
def sqrt(x: Any): ...
def acos(x: Any): ...
def atan2(x: Any, y: Any): ...
def solve_for(expression: Any, target_value: Any, start_value: float = ..., max_tries: int = ..., eps: float = ..., max_step: int = ...): ...
def gauss(n: Any): ...
def r_gauss(integral: Any): ...
def one_step_change(current_acceleration: Any, jerk_limit: Any, dt: Any): ...
def desired_velocity(current_position: Any, goal_position: Any, dt: Any, ph: Any): ...
def vel_integral(vel_limit: Any, jerk_limit: Any, dt: Any, ph: Any): ...
